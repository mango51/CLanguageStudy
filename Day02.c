#include <stdio.h>

/* ----- 입력 ------
	scanf() 함수를 사용해서 입력을 받는다.
	scanf("입력받을 서식 지정",입력받은 값을 저장할 변수의 주소)
	입력받을 서식을 지정할 때는 서식 지정자를 사용하면 되고 
	입력 받은 값을 저장할 변수의 주소를 표기해줄 때는 변수명 앞에 &(앰퍼샌드) 기호 붙여주기
		ex) scanf("%d",&num);
	scanf() 함수를 사용할 때 "" (큰 따옴표) 안에는 서식 지정자를 제외한 문자열은 작성하지 않는다.
	예외로 "" 큰 따옴표 안에 문자를 작성해주는 경우도 있음
		해당 문자로 입력값을 구분할 때 사용함
	scanf()함수에서 double 자료형을 가진 변수에 입력값을 저장할 때는 서식지정자 %lf 사용
*/
/* ----- 상수 ------
	항상 같은 수
	변경할 수 없는 데이터 (변수와 반대)
	1. 리터럴 상수: 사용자가 입력하는 문자 그대로를 의미함. 즉, 문자, 정수, 실수, 문자열 그 자체
	2. 심볼릭 상수: 이름을 가지고 있는 상수
	심볼릭 상수를 선언하는 방법: const 자료형 상수명; 혹은 자료형 const 상수명;
	심볼릭 상수 선언하기 위해 자료형의 앞이나 뒤에 const 구문 추가해주기
	심볼릭 상수 선언할 때 반드시 초기화를 같이 진행*
	아닐 경우 값을 할당하는데 어려움 발생
*/
/* ----- 형 변환 -----
	C언어에서 연산이 진행될 때 모든 값이 같은 타입으로 자료형 변환 후 연산이 진행되는데
	이를 형 변환이라고 함
	1. 자동 형 변환: C 컴파일러가 자동으로 진행해주는 형 변환
	char(1byte)->short(2byte)->int(4byte)->long(4)->float(4)->double(8) 순서로 진행
	자료형의 크기가 큰 쪽으로 자동 형 변환 진행
	char + int이면 char을 int형으로 자동 형 변환
	float + int 이면 int를 float형으로 자동 형 변환 (같은 크기의 자료형이지만 데이터의 손실을 최소화하기 위해 float형으로 변환)
	정수와 실수가 연산이 진행될 때, 데이터의 손실이 적은 실수형으로 형 변환 진행 (같은 크기의 자료형일지라도)
	2. 강제 형 변환: 사용자가 캐스트 연산자를 사용해 강제적으로 수행하는 형 변환
	강제 형 변환을 진행할 때, 변환하고 싶은 데이터 앞에 (변환할 자료형) 작성하기
*/

/* ----- 산술 연산자 -----
	+: 왼쪽의 피연산자에서 오른쪽의 피연산자를 더함
	-: 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌
	*: 왼쪽의 피연산자에서 오른쪽의 피연산자를 곱함
	/: 왼쪽의 피연산자를 오른쪽의 피연산자를 나눔 
		ex) 10/3 = int형/int형 = int형 = 몫 (자동 형 변환되어 출력)
	%: 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후 나머지 반환

	연산자 우선 순위 : (),[] > !,~,++,-- > *,/,% > +,- > <<,>> > ...있음
*/

/* ----- 대입 연산자 ----- 
	= : 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함
		ex) num=3 ; 3이라는 값을 num에 대입하기
*/

/* ----- 복합 대입 연산자 ----- 
	+= : 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결과값을 왼쪽의 피연산자에 대입
	-= : 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결과값을 왼쪽의 피연산자에 대입
	*= : 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결과값을 왼쪽의 피연산자에 대입
	/= : 왼쪽의 피연산자에 오른쪽의 피연산자로 나눈 후, 그 결과값을 왼쪽의 피연산자에 대입
	%= : 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입
*/

/* ----- 증감 연산자 -----
	다른 연산자들과 다르게 피연산자가 한 개임
	++num(전위 증가 연산자) : 피연산자의 값을 1증가시킨 후, 연산 진행
	num++(후위 증가 연산자) : 연산을 먼저 진행하고 나서 피연산자의 값을 1 증가
	--num(전위 감소 연산자) : 피연산자의 값을 1감소시킨 후, 연산 진행
	num--(후위 감소 연산자) : 연산 먼저 진행하고 피연산자 값 1 감소
*/

/* ----- 비교 연산자 -----
	연산의 결과가 참일 경우 1, 거짓일 경우 0 반환 (대표적인 참/거짓 값 지정)
	== : 왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 1 반환
	!= : 왼쪽의 피연산자와 오른쪽의 피연산자가 다르면 1 반환
	 > : 왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 1 반환
	 < : 왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 1 반환
	>= : 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 1 반환
	<= : 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 1 반환
*/

/* ----- 논리 연산자 ------
	&& (엔퍼센드 2개) : 논리 AND 연산, 논리식이 모두 참이면 1, 둘 중 하나라도 거짓이면 0 반환
		거짓 && 거짓 = 0 >> 0 && 0 = 0
		참 && 거짓 = 0 >> 1 && 0 = 0
		참 && 참 = 1 >> 1 && 1 = 1
	|| (파이프 2개) : 논리 OR 연산, 논리식 둘 중 하나라도 참이면 1 반환
		거짓 || 거짓 = 0 >> 0||0= 0
		참 || 거짓 = 1 >> 1||0 = 1
		참 || 참 = 1 >> 1||1 = 1
	! : 논리 NOT 연산, 참이면 거짓, 거짓이면 참으로 반전
		논리 NOT 연산의 경우, 피연산자가 한 개만 존재
		!7 = 0, !3 = 0, !1 =0 ... (C언어는 0외의 값들은 모두 1로 취급함)
		!0 = 1
		C언어는 0 이외의 값들은 모두 1로 취급함 >> 1,2,3,4...., -1,-2,-3.... 은 컴퓨터에서 1로 취급함 <-> 0만 0으로 취급함

	논리 AND 연산인 경우, 왼쪽의 논리식이 거짓 (0) 일 경우, 오른쪽의 논리식 진행 안함
	논리 OR 연산인 경우, 왼쪽의 논리식이 참 (1) 인 경우, 오른쪽의 논리식 진행 안함
*/

/* ----- 비트 연산자 -----
	10진수를 2진수 형태로 변환하여 각 비트별로 연산 진행

	*/

int main() {
	/* int num;
	printf("입력: ");
	scanf("%d", &num);
	// num은 입력받은 값을 저장할 변수
	// &num은 입력받은 값을 저장할 num의 주소
	printf("출력: %d\n", num);
	// &num 주소를 통해 num에 저장된 값을 출력 함수를 통해 출력하기 */

	/* int num1, num2;
	printf("입력: ");
	scanf("%d,%d", &num1, &num2); 
	// scanf()함수를 사용할 때 "" 큰 따옴표 안에 문자열 작성하지 않지만 위의 코드처럼 %d와 다른 %d를 구분하기 위해 %d,%d로 문자열 사용할 수도 있음
	printf("출력: %d %d\n", num1, num2); */

	/*char ch;
	printf("입력: ");
	scanf("%c", &ch);
	printf("출력: %c\n", ch); */

	/*double db;
	printf("입력: ");
	scanf("%lf", &db);
	printf("출력: %lf\n", db);
	// 출력시에는 double형 변수를 출력할 때 %f 혹은 %lf해도 상관없음 */

	/* char letter1;
	char letter2;
	printf("입력: ");
	scanf("%c %c", &letter1, &letter2);
	printf("출력: %c %c\n", letter2, letter1);

	int year;
	int month;
	int day;
	printf("입력: ");
	scanf("%d-%d-%d", &year, &month, &day);
	printf("출력: %d년 %02d월 %02d일\n", year, month, day);
	// %02d : 2자리 정수로 만들고 빈 공간은 0으로 채우기

	int num1, num2, num3, num4,num5,num6,num7,num8;
	printf("입력: ");
	scanf("%d %d %d %d %d %d %d %d", &num1, &num2, &num3, &num4, &num5, &num6, &num7, &num8);
	printf("출력: %c%c%c%c%c%c%c%c", num1, num2, num3, num4, num5, num6, num7, num8); 
	// int형 아스키코드를 %c에 넣어서 int형 아스키코드에서 %c를 통해 문자로 변환해준 후 출력 97 = a의 int형 아스키코드, a= int형으로는 97
	*/

	/* printf("연산 결과: %.1f\n", 3 + 4.3); // 자동 형 변환 : int+double -> double(int형을 자동 형 변환함)+double = double
	printf("연산 결과: %d\n", 3 + (int)4.5);
	const int con=7;
	printf("%d\n", con);*/

	/* int num1, num2, num3;
	num1 = 9 + 8 / 2 * 4; // 25
	num2 = 8 - 12 * (2 + 2) / 8 % 2; //8
	num3 = 1 % 3 * (1 + 3) * (12 / 6) % 10; // 8

	printf("%d %d %d", num1, num2, num3); */

	/* int num = 7;
	num += 11; // num = num+11 과 동일
	// 다른 점은 피연산자의 개수가 다름 >> 실행코드는 주석으로 되어 있는 코드보다 간결하고 효율적이라서 주로 사용
	// num = num+11 = 7+11= 18
	printf("num의 값: %d\n", num); */

	/* int n1 = 5, n2 = 13, n3,n4;
	n3 = n1++ + ++n2; // n1은 5, n2는 13+1=14임 >> n1+n2= 19이므로 n3은 19임 (연산 후, n1은 5+1 = 6이 됨)
	n4 = n2++ + n2 + n1; // 14+14(아직 안 바뀜, 연산 '끝나고' n2가 15로 바뀜)+6 = 34 (연산 끝나고 n2 = 14+1 = 15가 됨)
	printf("%d %d", n3,n4);
	//연산 끝나고 증감 연산자 반영됨 */

	/* int a = 5, b = 6, c = 10, d;
	d = ++a * b--;	// 연산 후, a=6,b=5, d=36 (= 6*6)
	d = a++ + ++c - b--; // 연산 후, a=7,b=4,c=11, d= 12(=6+11-5) */

	/* int num1 = 10, num2 = 20, num3 = 4;
	int num4 = 13, num5 = 4;

	printf("%d\n", num1 == num2); //0
	printf("%d\n", num4 != num1); //1 num4와 num1이 다르면 true이므로 1반환
	printf("%d\n", num4 > num2);  //0
	printf("%d\n", num5 >= num3); //1
	printf("%d\n", num1 < num4);  //1
	printf("%d\n", num3 <= num1); //1 
	*/

	/* int num1 = 10, num2 = 20, num3 = 4, num4 = 13, num5 = 4;

	printf("%d\n", num5>=num3||num1==num2); // 1||0 = 1
	printf("%d\n", num4!=num1&&num1<num4);	// 1&&1 = 1
	printf("%d\n", num4>num2 && num3==num5);// 0&&1 = 0
	printf("%d\n", !num5>num3);				// 0>4 = 0
	printf("%d\n", !(num1>num4)||num3<=num1);//1||1 = 1

	논리 OR 연산인 경우, 하나라도 참(1)이면 무조건 참(1) >> 앞의 내용 참이면 뒤의 내용 연산 자체를 안함 >> 무조건 결과가 참(1)이기 때문에
	논리 AND 연산인 경우, 하나라도 거짓(0)이면 무조건 거짓(0) >> 앞의 내용 거짓이면 뒤의 내용 연산 자체 안함 >> 무조건 결과가 거짓(0)이기 때문

	// *** C언어에는 !0 = 1이지만 !1, !2, !3... 0외의 다른 값들은 모두 1로 취급함 */

	/*
	int a = 1, b = 0, c = 12, d = 12;
	d = a++ || ++b * d-- / ++c;
	// 1|| ...이니 뒤에 연산하지 않고 무조건 결과값 1
	// 뒤에 연산 안하니 나머지 b,c의 값은 유지됨
	// a=2, b=0, c=12, d=1 (d는 a++||으로 1||이니까 무조건 결과값 1)
	// OR연산자는 앞에가 1이면 무조건 결과값 1이므로 뒤의 내용 연산 안함!!!

	d = b++ && ++a / ++c * d++; 
	// b++ && 이므로 0&& 이니까 결과값 무조건 0임
	// 논리 AND 연산에서 앞이 0이면 무조건 결과값 0이기 때문이기에 뒤의 내용 연산 안함!!!
	// a=2, b=1, c=12, d=0 (d는 b++&&으로 0&&이니까 무조건 결과값 0)

	//논리 OR 연산인 경우, 하나라도 참(1)이면 무조건 참(1) >> 앞의 내용 참이면 뒤의 내용 연산 자체를 안함 >> 무조건 결과가 참(1)이기 때문에
	//논리 AND 연산인 경우, 하나라도 거짓(0)이면 무조건 거짓(0) >> 앞의 내용 거짓이면 뒤의 내용 연산 자체 안함 >> 무조건 결과가 거짓(0)이기 때문
	*/
	
	// 3
	// 11
	// 24
	
	return 0;
}